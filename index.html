<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FUNTIMECHAT</title>
    <link rel="stylesheet" href="style.css"> 
    </head>
<body>

    <div id="loading-screen" class="screen active">
        <div class="logo-pulse">MH</div> <p>Loading FunTimeChat...</p>
    </div>

    <div id="app-container" style="display:none;">

        <header id="topbar">
            <div class="logo">MH</div>
            <h1 id="current-view-title">Welcome</h1>
            <div class="controls">
                <button id="theme-toggle">â˜€ï¸/ğŸŒ™</button>
                <button id="admin-panel-btn" style="display:none;">ğŸ”‘ Admin</button>
                <img id="user-photo" src="default.png" alt="Profile" class="profile-pic" style="display:none;">
                <button id="signout-btn" style="display:none;">Logout</button>
            </div>
        </header>

        <main id="main-content">
            <div id="auth-view" class="view active">
                <h2>Sign In / Sign Up</h2>
                <div class="auth-card">
                    <button id="google-signin-btn" class="square-btn type-b">Sign in with Google</button>
                    <hr>
                    <input type="email" id="email-input" placeholder="Email">
                    <input type="password" id="password-input" placeholder="Password">
                    <button id="email-signin-btn" class="square-btn type-b">Sign In</button>
                    <button id="email-signup-btn" class="square-btn type-b">Sign Up</button>
                    <button id="forgot-password-btn">Forgot Password?</button>
                    <button id="anonymous-login-btn">Continue as Guest</button>
                </div>
            </div>

            <div id="public-chat-view" class="view" style="display:none;">
                <div class="room-selector">
                    <button class="square-btn type-b active-room">Global Chat</button>
                </div>
                <div id="messages-container" class="message-list-area">
                    </div>
                <div id="public-typing-indicator" class="typing-status" style="display:none;"></div>
                <div class="input-area" style="position:relative;">
                    <input type="text" id="message-input" placeholder="Type a message...">
                    <button id="public-emoji-btn">ğŸ˜Š</button> 
                    <button id="send-message-btn" class="square-btn type-b">â¡ï¸</button>
                    <div id="public-emoji-picker" class="emoji-picker" style="display:none;"></div>
                </div>
            </div>

            <div id="inbox-view" class="view" style="display:none;">
                <button id="back-to-inbox-list" class="square-btn type-b" style="display:none; width:auto; margin-bottom: 10px;">â† Back to Inbox</button>
                <h2 id="inbox-title">Private Messages (Inbox)</h2>
                <div id="chat-list-container" class="message-list-area">
                    <p>Loading your private chats...</p>
                </div>
                <div id="private-chat-room" style="display:none; height:100%; flex-direction:column;">
                    <div id="chat-header-controls" style="display:flex; justify-content:space-between; align-items:center; padding-bottom:10px; border-bottom:1px solid #eee;">
                        <span id="chat-partner-name" style="font-weight:bold;"></span>
                        <div class="call-buttons">
                            <button id="start-audio-call-btn" class="square-btn type-b" style="width: auto; padding: 5px 10px; margin: 0 5px;">ğŸ“ Audio</button>
                            <button id="start-video-call-btn" class="square-btn type-b" style="width: auto; padding: 5px 10px; margin: 0 0;">ğŸ“¹ Video</button>
                        </div>
                    </div>
                    <div id="private-messages-container" class="message-list-area" style="flex-grow:1; height: auto;"></div>
                    <div id="private-typing-indicator" class="typing-status" style="display:none;"></div>
                    <div class="input-area" style="position:relative;">
                        <input type="text" id="private-message-input" placeholder="Type private message...">
                        <button id="private-emoji-btn">ğŸ˜Š</button>
                        <button id="private-send-message-btn" class="square-btn type-b">â¡ï¸</button>
                        <div id="private-emoji-picker" class="emoji-picker" style="display:none;"></div>
                    </div>
                </div>
            </div>

            <div id="random-chat-view" class="view" style="display:none;">
                <h2>Random Chat</h2>
                <p>Click 'Start Match' to find a stranger!</p>
                <button id="start-random-match-btn" class="square-btn type-b">Start Match</button>
            </div>
            
            <div id="friends-view" class="view" style="display:none;">
                <h2>Friends & Requests</h2>
                
                <div class="search-area" style="margin-bottom: 20px;">
                    <input type="text" id="friend-search-input" placeholder="Search user by display name or email part...">
                    <button id="friend-search-btn" class="square-btn type-b">ğŸ” Search</button>
                </div>
                <div id="search-results-container" style="margin-bottom: 20px;"></div>

                <h3 style="border-bottom: 1px solid #ccc; padding-bottom: 5px;">Friend Requests</h3>
                <div id="requests-container" class="message-list-area" style="max-height: 200px; overflow-y: auto; margin-bottom: 20px;">
                    <p>No new requests.</p>
                </div>

                <h3 style="border-bottom: 1px solid #ccc; padding-bottom: 5px;">My Friends</h3>
                <div id="friends-list-container" class="message-list-area" style="flex-grow: 1; overflow-y: auto;">
                    <p>Your friend list is empty. Find users using the search bar above!</p>
                </div>
            </div>
            
            <div id="admin-view" class="view" style="display:none;">
                <h2>ğŸ”‘ Admin Dashboard</h2>
                <p>Manage users and global content.</p>
                <div class="admin-panel-tabs">
                    <button class="square-btn type-b active-tab" data-tab="users-tab">Users</button>
                    <button class="square-btn type-b" data-tab="public-chat-tab">Public Chat</button>
                </div>
                
                <div id="users-tab" class="admin-tab-content active">
                    <h3>Registered Users</h3>
                    <div id="admin-users-list" class="message-list-area">
                        <p>Loading user list...</p>
                    </div>
                </div>
                
                <div id="public-chat-tab" class="admin-tab-content" style="display:none;">
                    <h3>Public Messages</h3>
                    <div id="admin-public-messages" class="message-list-area">
                        <p>Loading messages...</p>
                    </div>
                </div>
            </div>
            
        </main>

        <div id="call-overlay" class="call-ui" style="display:none;">
            <h2 id="call-status">Connecting...</h2>
            <video id="local-video" autoplay muted style="width:100%; max-height:200px; background:#000;"></video>
            <video id="remote-video" autoplay style="width:100%; max-height:400px; background:#000;"></video>
            <div id="call-controls">
                <button id="end-call-btn" class="square-btn type-b" style="background:#dc3545;">ğŸ”´ End Call</button>
                <button id="accept-call-btn" class="square-btn type-b" style="background:#28a745; display:none;">âœ… Accept</button>
                <button id="reject-call-btn" class="square-btn type-b" style="background:#dc3545; display:none;">âŒ Reject</button>
            </div>
        </div>

        <nav id="bottom-nav">
            <button data-view="public-chat-view">ğŸ’¬ Public</button>
            <button data-view="inbox-view">âœ‰ï¸ Inbox</button>
            <button data-view="random-chat-view">ğŸ² Random</button>
            <button data-view="friends-view">ğŸ‘¥ Friends</button>
        </nav>

        <footer id="legal-footer">
            <a href="privacy.html">Privacy Policy</a> | <a href="terms.html">Terms</a> | <a href="report.html">Report</a>
        </footer>
    </div>

    <audio id="new-message-sound" src="message.mp3" preload="auto"></audio>
    <audio id="incoming-call-ringtone" src="ringtone.mp3" preload="auto"></audio>

    <script type="module">
        
        // ğŸš¨ STEP 1: Firebase Configuration (Your Details)
        const firebaseConfig = {
            apiKey: "AIzaSyB__tJ3sv3cB2N3vKHFCv8SYngJENQxwhY",
            authDomain: "funtimechat69-39947.firebaseapp.com",
            databaseURL: "https://funtimechat69-39947-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "funtimechat69-39947",
            storageBucket: "funtimechat69-39947.appspot.com", // This is not used, but kept for config integrity
            messagingSenderId: "559638056734",
            appId: "1:559638056734:web:9329d2b561b6fab106830f"
        };

        // ğŸš¨ STEP 2: Necessary Firebase SDK Imports 
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
        import { 
            getAuth, signInWithPopup, GoogleAuthProvider, createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, sendPasswordResetEmail, onAuthStateChanged, 
            signOut, signInAnonymously, updateProfile 
        } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
        import { 
            getDatabase, ref, push, onValue, serverTimestamp, query, limitToLast, set, remove, off, get, update
        } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";
        // Firebase Storage imports are removed as requested.

        // Initialize Firebase Services
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getDatabase(app);
        // const storage = getStorage(app); // Storage initialization removed

        // Global variables
        let currentUserIsAdmin = false;
        let typingTimeout = null; // for Point 11
        
        // Utility function to switch views (Point 1)
        const handleNavigation = (viewId) => {
            document.querySelectorAll('.view').forEach(view => {
                view.style.display = 'none'; 
            });
            const newView = document.getElementById(viewId);
            if(newView) {
                if (viewId === 'public-chat-view' || viewId === 'inbox-view') {
                     newView.style.display = 'flex';
                } else {
                     newView.style.display = 'block';
                }
               
                document.getElementById('current-view-title').textContent = newView.querySelector('h2')?.textContent || 'FunTimeChat';
            }
        };

        // ***************************************************************
        // 8. NOTIFICATION SYSTEM
        // ***************************************************************
        
        const requestNotificationPermission = () => {
            if (Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        console.log("Notification permission granted.");
                    }
                });
            }
        };

        const showNotification = (title, body) => {
            document.getElementById('new-message-sound').play().catch(e => console.log("Sound play failed:", e));

            if (Notification.permission === 'granted' && document.hidden) {
                new Notification(title, {
                    body: body,
                    icon: 'default.png',
                    vibrate: [200, 100, 200]
                });
            }
        };
        
        const saveUserData = async (user) => {
            if (user && !user.isAnonymous) {
                const userRef = ref(db, `users/${user.uid}`);
                const userData = {
                    displayName: user.displayName || user.email?.split('@')[0] || 'User',
                    email: user.email || 'N/A',
                    photoURL: user.photoURL || 'default.png',
                    lastActive: serverTimestamp()
                };

                await set(userRef, userData, { merge: true }).catch(e => console.error("Error saving user data:", e));

                const snapshot = await get(userRef);
                const isAdmin = snapshot.val()?.isAdmin || false;
                currentUserIsAdmin = isAdmin; 
                document.getElementById('admin-panel-btn').style.display = isAdmin ? 'block' : 'none';
            }
        };

        // ***************************************************************
        // 2. ACCOUNT SYSTEM (AUTHENTICATION)
        // ***************************************************************

        onAuthStateChanged(auth, (user) => {
            document.getElementById('loading-screen').style.display = 'none';
            document.getElementById('app-container').style.display = 'flex'; 

            const userPhotoEl = document.getElementById('user-photo');
            const signoutBtn = document.getElementById('signout-btn');
            const adminBtn = document.getElementById('admin-panel-btn');

            if (user) {
                document.getElementById('auth-view').style.display = 'none';
                userPhotoEl.style.display = 'block';
                signoutBtn.style.display = 'block';
                adminBtn.style.display = 'none'; 

                userPhotoEl.src = user.photoURL || 'default.png';
                
                const currentViewDisplay = document.querySelector('#main-content > .view[style*="display: block"], #main-content > .view[style*="display: flex"]');
                if(!currentViewDisplay) {
                    handleNavigation('public-chat-view');
                }
                
                saveUserData(user); 
                requestNotificationPermission(); 
                loadChatList();
                loadFriendsData();
                setupCallListener(user.uid);
                setupPublicTypingListener(); // Point 11 setup
            } else {
                currentUserIsAdmin = false;
                document.getElementById('auth-view').style.display = 'block';
                userPhotoEl.style.display = 'none';
                signoutBtn.style.display = 'none';
                adminBtn.style.display = 'none';
                
                handleNavigation('auth-view');
            }
        });
        
        document.getElementById('google-signin-btn').addEventListener('click', async () => {
            const provider = new GoogleAuthProvider();
            try {
                await signInWithPopup(auth, provider);
            } catch (error) {
                alert("Google Sign-in failed: " + error.message);
            }
        });
        
        document.getElementById('email-signup-btn').addEventListener('click', async () => {
            const email = document.getElementById('email-input').value;
            const password = document.getElementById('password-input').value;
            try {
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                await updateProfile(userCredential.user, { displayName: email.split('@')[0] }); 
                alert("Sign Up successful! Logged in.");
            } catch (error) {
                alert("Sign Up failed: " + error.message);
            }
        });

        document.getElementById('email-signin-btn').addEventListener('click', async () => {
            const email = document.getElementById('email-input').value;
            const password = document.getElementById('password-input').value;
            try {
                await signInWithEmailAndPassword(auth, email, password);
                alert("Sign In successful!");
            } catch (error) {
                alert("Sign In failed: " + error.message);
            }
        });

        document.getElementById('anonymous-login-btn').addEventListener('click', async () => {
            try {
                await signInAnonymously(auth);
                alert("Signed in as Guest.");
            } catch (error) {
                alert("Anonymous Sign-in failed: " + error.message);
            }
        });

        document.getElementById('forgot-password-btn').addEventListener('click', async () => {
            const email = document.getElementById('email-input').value;
            if (email) {
                try {
                    await sendPasswordResetEmail(auth, email);
                    alert("Password reset email sent!");
                } catch (error) {
                    alert("Error sending reset email: " + error.message);
                }
            } else {
                alert("Please enter your email in the field above.");
            }
        });
        
        document.getElementById('signout-btn').addEventListener('click', async () => {
            try {
                await signOut(auth);
            } catch (error) {
                console.error("Logout Error:", error);
            }
        });

        // ***************************************************************
        // 3. PUBLIC CHAT SYSTEM & MESSAGE RENDERING
        // ***************************************************************

        const messagesContainer = document.getElementById('messages-container');
        const messageInput = document.getElementById('message-input');
        const sendMessageBtn = document.getElementById('send-message-btn');
        // const publicFileUploadInput = document.getElementById('public-file-upload-input'); // Removed
        // const publicUploadFileBtn = document.getElementById('public-upload-file-btn'); // Removed
        const publicTypingIndicator = document.getElementById('public-typing-indicator'); // Point 11
        const messagesRef = ref(db, 'public_rooms/global/messages');
        const typingRef = ref(db, 'public_rooms/global/typing'); // Point 11
        const recentMessagesQuery = query(messagesRef, limitToLast(100)); 

        const updateMessageSeenStatus = (messageKey, roomType, chatID) => {
            const currentUser = auth.currentUser;
            if (!currentUser) return;

            const path = roomType === 'public' 
                ? `public_rooms/global/messages/${messageKey}/reads/${currentUser.uid}`
                : `private_chats/${chatID}/messages/${messageKey}/reads/${currentUser.uid}`;
                
            set(ref(db, path), true)
                .catch(error => console.error("Error setting seen status:", error));
        };
        
        const renderMessage = (message, key, roomType, chatID, container) => {
            const currentUserUid = auth.currentUser?.uid;
            
            const reads = message.reads || {};
            const allUids = Object.keys(reads);
            
            let seenStatus = 'delivered'; 
            let seenCount = allUids.length - 1; 

            if (message.uid === currentUserUid) {
                if (seenCount >= 1) {
                    seenStatus = 'seen'; 
                } 
            } else {
                seenStatus = 'received';
                if (!reads[currentUserUid]) {
                    setTimeout(() => updateMessageSeenStatus(key, roomType, chatID), 500);
                }
            }

            const messageElement = document.createElement('div');
            // Assuming CSS provides styling for message-card, seen, delivered, received
            messageElement.className = `message-card ${seenStatus} ${message.uid === currentUserUid ? 'outgoing' : 'incoming'}`; 
            
            let contentHTML = '';
            // Media rendering logic removed (message.fileURL check removed)
            
            if (message.text) {
                // Point 12: Simple Emoji Text Conversion
                const textWithEmojis = message.text
                    .replace(/:\)/g, 'ğŸ˜Š')
                    .replace(/:\(/g, 'ğŸ˜')
                    .replace(/;-\)/g, 'ğŸ˜‰')
                    .replace(/:D/g, 'ğŸ˜')
                    .replace(/<3/g, 'â¤ï¸');
                    
                contentHTML += `<p class="message-text">${textWithEmojis}</p>`;
            } else {
                contentHTML += `<p class="message-text">[Empty Message]</p>`;
            }

            messageElement.innerHTML = `
                <div class="message-header">
                    <span class="user-name">${message.displayName || 'Anonymous'}</span>
                    <span class="timestamp">${message.timestamp ? new Date(message.timestamp).toLocaleTimeString() : '...'}</span>
                </div>
                ${contentHTML}
                <div class="message-status-ticks">
                    ${message.uid === currentUserUid ? (seenStatus === 'seen' ? 'âœ”ï¸âœ”ï¸' : 'âœ”ï¸') : ''}
                </div>
            `;
            messageElement.dataset.key = key; 
            container.appendChild(messageElement);
        };
        
        const sendChatMessage = async (containerRef, messageText) => {
            const currentUser = auth.currentUser;
            if (!currentUser || !messageText.trim()) { // Simplified message check
                alert("Message cannot be empty.");
                return;
            }

            const initialReads = {};
            initialReads[currentUser.uid] = true; 

            try {
                await push(containerRef, {
                    uid: currentUser.uid,
                    displayName: currentUser.displayName || 'Guest',
                    text: messageText,
                    // fileURL and fileType removed
                    timestamp: serverTimestamp(),
                    reads: initialReads, 
                });
                
                // Point 11: Reset typing status after sending message
                if (containerRef === messagesRef) {
                    await set(ref(db, `public_rooms/global/typing/${currentUser.uid}`), null);
                } 
                // Private chat typing cleanup is handled outside this function

            } catch (e) {
                console.error("Error sending message: ", e);
            }
        };

        sendMessageBtn.addEventListener('click', async () => {
            const messageText = messageInput.value.trim();
            if (messageText) { // File check removed
                await sendChatMessage(messagesRef, messageText);
                messageInput.value = '';
            } else {
                alert("Please type a message first.");
            }
        });

        // Receiving Messages Logic (Public Chat)
        onValue(recentMessagesQuery, (snapshot) => {
            const lastMessageKey = snapshot.val() ? Object.keys(snapshot.val()).pop() : null;
            let lastMessage = null;

            messagesContainer.innerHTML = ''; 
            snapshot.forEach((childSnapshot) => {
                const message = childSnapshot.val();
                renderMessage(message, childSnapshot.key, 'public', null, messagesContainer);
                if (childSnapshot.key === lastMessageKey) {
                    lastMessage = message;
                }
            });
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            if (lastMessage && lastMessage.uid !== auth.currentUser?.uid && document.getElementById('public-chat-view').style.display !== 'none') {
                 const messageBody = lastMessage.text || '[New Message]'; // File reference removed
                 showNotification(`New Global Message from ${lastMessage.displayName}`, messageBody);
            }
        });
        
        // ***************************************************************
        // 11. TYPING INDICATOR LOGIC
        // ***************************************************************

        // Function to set typing status
        const setTypingStatus = (typingRef, isTyping) => {
            const currentUser = auth.currentUser;
            if (!currentUser) return;
            const userTypingRef = ref(typingRef, currentUser.uid);

            if (isTyping) {
                set(userTypingRef, currentUser.displayName || 'A user');
                clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => {
                    setTypingStatus(typingRef, false);
                }, 3000); // Stop typing after 3 seconds of inactivity
            } else {
                set(userTypingRef, null);
            }
        };

        // Public chat input listener
        messageInput.addEventListener('keypress', () => {
            setTypingStatus(typingRef, true);
        });

        // Public typing status listener
        const setupPublicTypingListener = () => {
            onValue(typingRef, (snapshot) => {
                const typingUsers = snapshot.val();
                if (!typingUsers) {
                    publicTypingIndicator.style.display = 'none';
                    return;
                }

                const currentUser = auth.currentUser;
                const otherTypingUsers = Object.keys(typingUsers)
                    .filter(uid => uid !== currentUser?.uid)
                    .map(uid => typingUsers[uid]);
                
                if (otherTypingUsers.length > 0) {
                    const names = otherTypingUsers.join(', ');
                    publicTypingIndicator.textContent = `${names} is typing...`;
                    publicTypingIndicator.style.display = 'block';
                } else {
                    publicTypingIndicator.style.display = 'none';
                }
            });
        };


        // ***************************************************************
        // 4. PRIVATE CHAT (INBOX) SYSTEM 
        // ***************************************************************
        
        const chatListContainer = document.getElementById('chat-list-container');
        const privateMessagesContainer = document.getElementById('private-messages-container');
        const privateMessageInput = document.getElementById('private-message-input');
        const privateSendMessageBtn = document.getElementById('private-send-message-btn');
        // const privateFileUploadInput = document.getElementById('private-file-upload-input'); // Removed
        // const privateUploadFileBtn = document.getElementById('private-upload-file-btn'); // Removed
        const privateTypingIndicator = document.getElementById('private-typing-indicator'); // Point 11
        const backToInboxBtn = document.getElementById('back-to-inbox-list');
        const privateChatRoom = document.getElementById('private-chat-room');
        const chatPartnerNameEl = document.getElementById('chat-partner-name');
        
        let currentChatID = null; 
        let currentOtherUid = null; 
        let privateMessageListener = null; 
        let privateTypingListener = null; // Point 11

        const loadChatList = () => {
            if (!auth.currentUser) return;
            const chatsRef = ref(db, 'private_chats'); 

            onValue(chatsRef, async (snapshot) => {
                chatListContainer.innerHTML = '';
                let hasChats = false;
                const chatPromises = [];

                snapshot.forEach(childSnapshot => {
                    const chat = childSnapshot.val();
                    const chatID = childSnapshot.key;
                    
                    if (chat.participants && chat.participants[auth.currentUser.uid]) {
                        hasChats = true;
                        
                        const otherUid = Object.keys(chat.participants).find(uid => uid !== auth.currentUser.uid);
                        const otherDisplayName = chat.participants[otherUid]?.displayName || 'Stranger';
                        
                        const chatPromise = get(query(ref(db, `private_chats/${chatID}/messages`), limitToLast(1)))
                            .then(lastMessageSnapshot => {
                                let lastMessageText = 'Start chatting!';
                                let lastMessageTimestamp = chat.createdAt || 0; 
                                
                                lastMessageSnapshot.forEach(msgSnap => {
                                    const msg = msgSnap.val();
                                    lastMessageTimestamp = msg.timestamp;
                                    lastMessageText = msg.text; // Simplified to text only
                                });

                                return { chatID, otherUid, otherDisplayName, lastMessageText, lastMessageTimestamp };
                            });
                        chatPromises.push(chatPromise);
                    }
                });
                
                Promise.all(chatPromises).then(chatsData => {
                    chatsData.sort((a, b) => (b.lastMessageTimestamp || 0) - (a.lastMessageTimestamp || 0));

                    if (chatsData.length > 0) {
                        chatsData.forEach(data => {
                            const chatItem = document.createElement('div');
                            chatItem.className = 'chat-list-item'; 
                            chatItem.dataset.chatID = data.chatID;
                            chatItem.dataset.otherUid = data.otherUid; 
                            chatItem.dataset.otherName = data.otherDisplayName;
                            chatItem.innerHTML = `
                                <h3>${data.otherDisplayName}</h3>
                                <p>${(data.lastMessageText || 'Start chatting!').substring(0, 30)}...</p>
                                <span class="chat-time">${new Date(data.lastMessageTimestamp).toLocaleDateString()}</span>
                            `;
                            
                            chatItem.addEventListener('click', () => openPrivateChat(data.chatID, data.otherUid, data.otherDisplayName));
                            
                            chatListContainer.appendChild(chatItem);
                        });
                    } else if (!hasChats) {
                        chatListContainer.innerHTML = '<p>Your inbox is empty. Try starting a Random Chat or add a Friend!</p>';
                    }
                });
            });
        };

        const openPrivateChat = (chatID, otherUid, otherName) => {
            currentChatID = chatID;
            currentOtherUid = otherUid; 
            
            document.getElementById('inbox-title').textContent = `Chatting with ${otherName}`;
            chatPartnerNameEl.textContent = otherName; 
            chatListContainer.style.display = 'none';
            privateChatRoom.style.display = 'flex';
            backToInboxBtn.style.display = 'block';
            
            privateMessagesContainer.innerHTML = ''; 
            
            if (privateMessageListener) {
                off(privateMessageListener);
            }
            if (privateTypingListener) { 
                off(privateTypingListener);
            }

            const messagesRef = ref(db, `private_chats/${chatID}/messages`);
            const typingRef = ref(db, `private_chats/${chatID}/typing`); 
            const recentMessagesQuery = query(messagesRef, limitToLast(100)); 

            privateMessageListener = onValue(recentMessagesQuery, (snapshot) => {
                const lastMessageKey = snapshot.val() ? Object.keys(snapshot.val()).pop() : null;
                let lastMessage = null;

                privateMessagesContainer.innerHTML = '';
                snapshot.forEach((childSnapshot) => {
                    const message = childSnapshot.val();
                    renderMessage(message, childSnapshot.key, 'private', chatID, privateMessagesContainer);
                    if (childSnapshot.key === lastMessageKey) {
                        lastMessage = message;
                    }
                });
                privateMessagesContainer.scrollTop = privateMessagesContainer.scrollHeight;

                if (lastMessage && lastMessage.uid !== auth.currentUser?.uid && privateChatRoom.style.display === 'flex' && document.hidden) {
                    const messageBody = lastMessage.text || '[New Message]'; // File reference removed
                    showNotification(`New Message from ${otherName}`, messageBody);
                }
            });
            
            // Point 11. PRIVATE TYPING LISTENER
            privateTypingListener = onValue(typingRef, (snapshot) => {
                const typingUsers = snapshot.val();
                privateTypingIndicator.style.display = 'none';
                if (!typingUsers) return;

                const currentUser = auth.currentUser;
                const otherTypingUsers = Object.keys(typingUsers)
                    .filter(uid => uid !== currentUser?.uid && typingUsers[uid])
                    .map(uid => typingUsers[uid]);
                
                if (otherTypingUsers.length > 0) {
                    privateTypingIndicator.textContent = `${otherTypingUsers.join(', ')} is typing...`;
                    privateTypingIndicator.style.display = 'block';
                }
            });
            
             // Point 11. PRIVATE TYPING INPUT LISTENER setup for the current chat
            privateMessageInput.onkeypress = () => {
                if (currentChatID) {
                    setTypingStatus(ref(db, `private_chats/${currentChatID}/typing`), true);
                }
            };
        };


        privateSendMessageBtn.addEventListener('click', async () => {
            const messageText = privateMessageInput.value.trim();
            if (currentChatID) {
                if (messageText) { // File check removed
                    const messagesRef = ref(db, `private_chats/${currentChatID}/messages`);
                    await sendChatMessage(messagesRef, messageText);
                    privateMessageInput.value = '';
                    // Manually clear typing status after sending private message
                    await set(ref(db, `private_chats/${currentChatID}/typing/${auth.currentUser.uid}`), null);
                } else {
                    alert("Please type a message first."); // Alert simplified
                }
            } else {
                alert("Please select a private chat room first.");
            }
        });

        backToInboxBtn.addEventListener('click', () => {
            currentChatID = null;
            currentOtherUid = null;
            if (privateMessageListener) {
                off(privateMessageListener); 
            }
            if (privateTypingListener) { 
                off(privateTypingListener);
            }
            privateMessageInput.onkeypress = null; // Clear the keypress listener
            
            document.getElementById('inbox-title').textContent = 'Private Messages (Inbox)';
            chatListContainer.style.display = 'block';
            privateChatRoom.style.display = 'none';
            backToInboxBtn.style.display = 'none';
        });

        // ***************************************************************
        // 12. EMOJIS AND STICKERS LOGIC
        // ***************************************************************

        const emojis = [
            'ğŸ˜Š', 'ğŸ˜‚', 'ğŸ˜', 'ğŸ¤”', 'ğŸ˜', 'ğŸ˜­', 'ğŸ˜œ', 'ğŸ˜‡', 'ğŸ™ˆ', 'ğŸ™Š', 
            'ğŸ¶', 'ğŸ±', 'ğŸ‘', 'ğŸ‘', 'â¤ï¸', 'ğŸ”¥', 'ğŸ‰', 'ğŸ•', 'ğŸ»', 'âš½'
        ];

        const generateEmojiPicker = (pickerId, inputId) => {
            const picker = document.getElementById(pickerId);
            picker.innerHTML = '';
            emojis.forEach(emoji => {
                const button = document.createElement('button');
                button.textContent = emoji;
                button.dataset.emoji = emoji;
                button.addEventListener('click', (e) => {
                    e.preventDefault();
                    const input = document.getElementById(inputId);
                    input.value += e.target.dataset.emoji;
                    // Hide picker after selection
                    picker.style.display = 'none';
                    // Re-focus the input field
                    input.focus();
                });
                picker.appendChild(button);
            });
        };

        // Setup Emojis for Public Chat
        generateEmojiPicker('public-emoji-picker', 'message-input');
        document.getElementById('public-emoji-btn').addEventListener('click', (e) => {
            e.preventDefault();
            const picker = document.getElementById('public-emoji-picker');
            picker.style.display = picker.style.display === 'none' ? 'flex' : 'none';
            document.getElementById('private-emoji-picker').style.display = 'none'; // Close other picker
        });

        // Setup Emojis for Private Chat
        generateEmojiPicker('private-emoji-picker', 'private-message-input');
        document.getElementById('private-emoji-btn').addEventListener('click', (e) => {
            e.preventDefault();
            const picker = document.getElementById('private-emoji-picker');
            picker.style.display = picker.style.display === 'none' ? 'flex' : 'none';
            document.getElementById('public-emoji-picker').style.display = 'none'; // Close other picker
        });
        
        // Hide picker when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.input-area') && !e.target.closest('.emoji-picker')) {
                document.getElementById('public-emoji-picker').style.display = 'none';
                document.getElementById('private-emoji-picker').style.display = 'none';
            }
        });


        // ***************************************************************
        // 5. RANDOM CHAT SYSTEM (ACTIVE LOGIC)
        // ***************************************************************
        
        const randomChatBtn = document.querySelector('#bottom-nav button[data-view="random-chat-view"]');
        const randomChatView = document.getElementById('random-chat-view');
        let currentMatchListener = null; 
        
        const createNewRandomChat = (user1Uid, user2Uid) => {
            const chatID = [user1Uid, user2Uid].sort().join('_');
            const chatRef = ref(db, `private_chats/${chatID}`);
            const queueRef = ref(db, 'matchQueue');
            
            get(ref(db, `matchQueue/${user2Uid}`)).then((snapshot) => {
                const otherDisplayName = snapshot.val()?.displayName || 'Stranger';
                
                // Fetch current user's display name accurately
                get(ref(db, `users/${user1Uid}`)).then(userSnap => {
                    const userDisplayName = userSnap.val()?.displayName || 'User';

                    set(chatRef, {
                        participants: {
                            [user1Uid]: { displayName: userDisplayName },
                            [user2Uid]: { displayName: otherDisplayName } 
                        },
                        status: 'active',
                        createdAt: serverTimestamp()
                    })
                    .then(() => {
                        alert(`Match Found! You are now connected with ${otherDisplayName}. Check your Inbox.`);
                        randomChatView.innerHTML = `<h2>Random Chat</h2><p>Match Found with ${otherDisplayName}! Go to your Inbox to start chatting.</p><button id="start-random-match-btn" class="square-btn type-b">Start New Match</button>`;
                        handleNavigation('inbox-view'); 
                        loadChatList(); 
                    })
                    .catch(error => console.error("Error creating chat:", error));
                    
                    // Cleanup queue
                    remove(ref(db, `matchQueue/${user1Uid}`));
                    remove(ref(db, `matchQueue/${user2Uid}`));
                });
            });
        };

        const startRandomMatchmaking = async () => {
            const currentUser = auth.currentUser;
            if (!currentUser || currentUser.isAnonymous) {
                alert("Please sign in with a permanent account to start Random Chat.");
                return;
            }
            randomChatView.innerHTML = `<h2>Searching for a Match...</h2><p>Please wait while we connect you with a stranger.</p><button id="cancel-match-btn" class="square-btn type-b">Cancel Matchmaking</button>`;
            handleNavigation('random-chat-view');
            const queueRef = ref(db, 'matchQueue');
            
            await set(ref(db, `matchQueue/${currentUser.uid}`), {
                displayName: currentUser.displayName || 'Stranger',
                timestamp: serverTimestamp()
            });
            
            // Set up cancellation listener
            document.getElementById('cancel-match-btn').onclick = () => {
                remove(ref(db, `matchQueue/${currentUser.uid}`));
                if (currentMatchListener) {
                    off(currentMatchListener); 
                }
                randomChatView.innerHTML = `<h2>Random Chat</h2><p>Matchmaking cancelled. Click 'Start Match' to try again.</p><button id="start-random-match-btn" class="square-btn type-b">Start Match</button>`;
                document.getElementById('start-random-match-btn').addEventListener('click', startRandomMatchmaking);
            };
            
            // Start listening for a match
            const findMatch = onValue(queueRef, (snapshot) => {
                const queue = snapshot.val();
                if (!queue) return;
                const uidsInQueue = Object.keys(queue);
                
                // Find the oldest user in the queue other than the current user
                const potentialMatchUid = uidsInQueue
                    .filter(uid => uid !== currentUser.uid)
                    .sort((uidA, uidB) => queue[uidA].timestamp - queue[uidB].timestamp)[0];
                    
                if (potentialMatchUid) {
                    off(findMatch);
                    if (currentUser.uid < potentialMatchUid) {
                        createNewRandomChat(currentUser.uid, potentialMatchUid);
                    }
                }
            });
            currentMatchListener = findMatch; 
        };

        randomChatBtn.addEventListener('click', () => {
            if (auth.currentUser && !auth.currentUser.isAnonymous) {
                startRandomMatchmaking();
            } else {
                alert("Please sign in with a permanent account to use Random Chat.");
                handleNavigation('auth-view');
            }
        });

        document.getElementById('random-chat-view').addEventListener('click', (e) => {
            if (e.target.id === 'start-random-match-btn') {
                startRandomMatchmaking();
            }
        });

        // ***************************************************************
        // 6. AUDIO/VIDEO CALLS (WebRTC)
        // ***************************************************************
        
        const callOverlay = document.getElementById('call-overlay');
        const localVideo = document.getElementById('local-video');
        const remoteVideo = document.getElementById('remote-video');
        const callStatusEl = document.getElementById('call-status');
        let pc = null; 
        let localStream = null; 
        const iceServers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ],
        };

        const startCall = async (videoEnabled) => {
            if (!currentOtherUid) return alert("Error: No recipient found.");
            
            if (auth.currentUser.isAnonymous) {
                alert("Please sign in with a registered account to make calls.");
                return;
            }
            
            try {
                const constraints = { video: videoEnabled, audio: true };
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                localVideo.srcObject = localStream;
            } catch (error) {
                console.error("Error getting user media:", error);
                alert("Cannot access camera/mic. Check permissions.");
                return;
            }
            callOverlay.style.display = 'flex';
            callStatusEl.textContent = videoEnabled ? "Video Calling..." : "Audio Calling...";
            document.getElementById('accept-call-btn').style.display = 'none';
            document.getElementById('reject-call-btn').style.display = 'none';
            document.getElementById('end-call-btn').style.display = 'block';
            
            pc = new RTCPeerConnection(iceServers);
            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
            
            pc.ontrack = (event) => {
                remoteVideo.srcObject = event.streams[0];
            };
            
            const callRef = ref(db, `calls/${currentOtherUid}`); 
            
            pc.onicecandidate = async (event) => {
                if (event.candidate) {
                    await push(ref(db, `calls/${currentOtherUid}/iceCandidates`), {
                        candidate: event.candidate.toJSON(),
                        senderUid: auth.currentUser.uid
                    });
                }
            };
            
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            
            await set(callRef, {
                callerUid: auth.currentUser.uid,
                callerName: auth.currentUser.displayName || 'User',
                offer: pc.localDescription.toJSON(),
                callType: videoEnabled ? 'video' : 'audio',
                timestamp: serverTimestamp(),
                status: 'ringing'
            });
            
            callStatusEl.textContent = `Ringing ${chatPartnerNameEl.textContent}...`;
            document.getElementById('incoming-call-ringtone').play();
            
            // Listen for answer/reject from the receiver
            onValue(ref(db, `calls/${currentOtherUid}`), (snapshot) => {
                const data = snapshot.val();
                if (data?.status === 'answered' && data?.answer) {
                    off(ref(db, `calls/${currentOtherUid}`)); 
                } else if (data?.status === 'rejected') {
                    alert(`${chatPartnerNameEl.textContent} rejected your call.`);
                    endCall();
                }
            }, {onlyOnce: true});
        };

        const answerCall = async (callData) => {
            const isVideoCall = callData.callType === 'video';
            try {
                const constraints = { video: isVideoCall, audio: true };
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                localVideo.srcObject = localStream;
            } catch (error) {
                console.error("Error getting user media:", error);
                alert("Cannot access camera/mic. Check permissions.");
                endCall();
                return;
            }
            callOverlay.style.display = 'flex';
            callStatusEl.textContent = "Connecting...";
            document.getElementById('accept-call-btn').style.display = 'none';
            document.getElementById('reject-call-btn').style.display = 'none';
            document.getElementById('end-call-btn').style.display = 'block';
            document.getElementById('incoming-call-ringtone').pause();
            
            pc = new RTCPeerConnection(iceServers);
            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
            
            pc.ontrack = (event) => {
                remoteVideo.srcObject = event.streams[0];
                callStatusEl.textContent = "Call Connected!";
            };
            
            const answerRef = ref(db, `calls/${callData.callerUid}`); 
            
            pc.onicecandidate = async (event) => {
                if (event.candidate) {
                    await push(ref(db, `calls/${callData.callerUid}/iceCandidates`), {
                        candidate: event.candidate.toJSON(),
                        senderUid: auth.currentUser.uid
                    });
                }
            };
            
            await pc.setRemoteDescription(new RTCSessionDescription(callData.offer));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            
            await update(answerRef, {
                answer: pc.localDescription.toJSON(),
                status: 'answered'
            });
            
            // Listen for ICE candidates from the caller
            onValue(ref(db, `calls/${auth.currentUser.uid}/iceCandidates`), (snapshot) => {
                snapshot.forEach(async (childSnapshot) => {
                    const candidateData = childSnapshot.val();
                    if (candidateData.senderUid !== auth.currentUser.uid) {
                        try {
                            await pc.addIceCandidate(new RTCIceCandidate(candidateData.candidate));
                        } catch (e) {
                            console.error("Error adding ICE candidate:", e);
                        }
                    }
                });
            });
            
            // Clean up the call entry for the receiver
            remove(ref(db, `calls/${auth.currentUser.uid}`));
        };

        const endCall = () => {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            if (pc) {
                pc.close();
                pc = null;
            }
            // Clear call state in DB for the current user (if they are the one ending)
            remove(ref(db, `calls/${auth.currentUser.uid}`));
            
            callOverlay.style.display = 'none';
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            document.getElementById('incoming-call-ringtone').pause();
        };

        const setupCallListener = (uid) => {
            const receiverRef = ref(db, `calls/${uid}`);

            onValue(receiverRef, async (snapshot) => {
                const callData = snapshot.val();
                
                if (!callData) {
                    if (pc) {
                        alert("Call ended by the other party.");
                        endCall();
                    }
                    return;
                }
                
                if (callData.status === 'ringing' && callData.callerUid !== uid) {
                    // Incoming call (Receiver)
                    showNotification(`Incoming Call`, `New ${callData.callType} call from ${callData.callerName}!`);
                    
                    callOverlay.style.display = 'flex';
                    callStatusEl.textContent = `Incoming ${callData.callType} call from ${callData.callerName}...`;
                    document.getElementById('end-call-btn').style.display = 'none';
                    document.getElementById('accept-call-btn').style.display = 'block';
                    document.getElementById('reject-call-btn').style.display = 'block';
                    document.getElementById('incoming-call-ringtone').play();
                    
                    document.getElementById('accept-call-btn').onclick = () => answerCall(callData);
                    document.getElementById('reject-call-btn').onclick = () => {
                        update(ref(db, `calls/${callData.callerUid}`), { status: 'rejected' });
                        endCall();
                    };
                } 
                
                else if (callData.status === 'answered' && callData.answer && pc && callData.callerUid === uid) {
                    // Call answered (Caller)
                    await pc.setRemoteDescription(new RTCSessionDescription(callData.answer));
                    callStatusEl.textContent = "Call Connected!";
                    
                    // Listen for ICE candidates from the answerer
                    onValue(ref(db, `calls/${uid}/iceCandidates`), (snapshot) => {
                        snapshot.forEach(async (childSnapshot) => {
                            const candidateData = childSnapshot.val();
                            if (candidateData.senderUid !== auth.currentUser.uid) {
                                try {
                                    await pc.addIceCandidate(new RTCIceCandidate(candidateData.candidate));
                                } catch (e) {
                                    console.error("Error adding ICE candidate:", e);
                                }
                            }
                        });
                    });
                    
                    remove(ref(db, `calls/${uid}/answer`));
                } else if (callData.status === 'rejected' && callData.callerUid === uid) {
                    // Call rejected (Caller)
                    alert(`${chatPartnerNameEl.textContent || callData.callerName} rejected your call.`);
                    endCall();
                }
            });
        };
        
        document.getElementById('start-audio-call-btn').addEventListener('click', () => startCall(false));
        document.getElementById('start-video-call-btn').addEventListener('click', () => startCall(true));
        document.getElementById('end-call-btn').addEventListener('click', endCall);


        // ***************************************************************
        // 7. FRIENDS SYSTEM
        // ***************************************************************
        
        const friendSearchInput = document.getElementById('friend-search-input');
        const friendSearchBtn = document.getElementById('friend-search-btn');
        const searchResultsContainer = document.getElementById('search-results-container');
        const requestsContainer = document.getElementById('requests-container');
        const friendsListContainer = document.getElementById('friends-list-container');
        const usersRef = ref(db, 'users'); 

        const searchUser = async () => {
            const searchTerm = friendSearchInput.value.trim().toLowerCase();
            searchResultsContainer.innerHTML = '';
            
            if (auth.currentUser.isAnonymous) {
                searchResultsContainer.innerHTML = '<p>Please sign in with a permanent account to search for friends.</p>';
                return;
            }
            
            if (searchTerm.length < 3) {
                searchResultsContainer.innerHTML = '<p>Enter at least 3 characters to search.</p>';
                return;
            }
            const snapshot = await get(usersRef);
            if (!snapshot.exists()) return;
            const users = snapshot.val();
            const currentUid = auth.currentUser.uid;
            let found = false;
            Object.keys(users).forEach(uid => {
                const user = users[uid];
                const displayName = user.displayName?.toLowerCase() || '';
                const email = user.email?.toLowerCase() || '';
                
                if (uid !== currentUid && (displayName.includes(searchTerm) || email.includes(searchTerm))) {
                    found = true;
                    const friendItem = document.createElement('div');
                    friendItem.className = 'chat-list-item'; 
                    friendItem.innerHTML = `
                        <h3>${user.displayName || user.email}</h3>
                        <p>UID: ${uid.substring(0, 8)}...</p>
                        <button class="send-request-btn square-btn type-b" data-uid="${uid}">+ Add Friend</button>
                    `;
                    searchResultsContainer.appendChild(friendItem);
                }
            });
            if (!found) {
                searchResultsContainer.innerHTML = '<p>No users found matching your search.</p>';
            }
        };
        friendSearchBtn.addEventListener('click', searchUser);

        const sendFriendRequest = async (targetUid) => {
            const currentUser = auth.currentUser;
            if (!currentUser || targetUid === currentUser.uid) return;
            
            const requestRef = ref(db, `user_friends/${targetUid}/requests/${currentUser.uid}`);
            await set(requestRef, {
                senderName: currentUser.displayName || currentUser.email,
                timestamp: serverTimestamp()
            });
            alert(`Friend request sent to user ${targetUid.substring(0, 8)}...`);
            
            const btn = document.querySelector(`.send-request-btn[data-uid="${targetUid}"]`);
            if(btn) {
                 btn.textContent = 'Request Sent';
                 btn.disabled = true;
            }
        };

        searchResultsContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('send-request-btn')) {
                const targetUid = e.target.dataset.uid;
                sendFriendRequest(targetUid);
            }
        });

        const acceptFriendRequest = async (senderUid, senderName) => {
            const currentUser = auth.currentUser;
            if (!currentUser) return;
            
            const currentUserName = currentUser.displayName || currentUser.email;
            const chatID = [currentUser.uid, senderUid].sort().join('_');
            
            // Add to current user's friends list
            await set(ref(db, `user_friends/${currentUser.uid}/friends/${senderUid}`), {
                displayName: senderName,
                timestamp: serverTimestamp(),
                chatID: chatID
            });
            
            // Add to sender's friends list
            await set(ref(db, `user_friends/${senderUid}/friends/${currentUser.uid}`), {
                displayName: currentUserName,
                timestamp: serverTimestamp(),
                chatID: chatID
            });
            
            // Remove request
            await remove(ref(db, `user_friends/${currentUser.uid}/requests/${senderUid}`));
            
            // Create private chat entry
            const chatRef = ref(db, `private_chats/${chatID}`);
            await set(chatRef, {
                participants: {
                    [currentUser.uid]: { displayName: currentUserName },
                    [senderUid]: { displayName: senderName } 
                },
                status: 'active',
                createdAt: serverTimestamp()
            });
            
            alert(`${senderName} is now your friend!`);
        };

        const rejectFriendRequest = async (senderUid) => {
            const currentUser = auth.currentUser;
            if (!currentUser) return;
            await remove(ref(db, `user_friends/${currentUser.uid}/requests/${senderUid}`));
        };

        const loadFriendsData = () => {
            const currentUser = auth.currentUser;
            if (!currentUser || currentUser.isAnonymous) return;
            const userFriendsRef = ref(db, `user_friends/${currentUser.uid}`);

            // Load Incoming Requests
            onValue(ref(userFriendsRef, 'requests'), (snapshot) => {
                requestsContainer.innerHTML = '';
                if (!snapshot.exists()) {
                    requestsContainer.innerHTML = '<p>No new requests.</p>';
                    return;
                }
                snapshot.forEach(childSnapshot => {
                    const senderUid = childSnapshot.key;
                    const request = childSnapshot.val();
                    const requestItem = document.createElement('div');
                    requestItem.className = 'chat-list-item'; 
                    requestItem.innerHTML = `
                        <h3>${request.senderName}</h3>
                        <div style="display:flex; gap:5px;">
                            <button class="accept-request-btn square-btn type-b" data-uid="${senderUid}" data-name="${request.senderName}">âœ… Accept</button>
                            <button class="reject-request-btn square-btn type-b" data-uid="${senderUid}">âŒ Reject</button>
                        </div>
                    `;
                    requestsContainer.appendChild(requestItem);
                });
            });
            
            // Load Friends List
            onValue(ref(userFriendsRef, 'friends'), (snapshot) => {
                friendsListContainer.innerHTML = '';
                if (!snapshot.exists()) {
                    friendsListContainer.innerHTML = '<p>Your friend list is empty. Find users using the search bar above!</p>';
                    return;
                }
                snapshot.forEach(childSnapshot => {
                    const friendUid = childSnapshot.key;
                    const friend = childSnapshot.val();
                    const friendItem = document.createElement('div');
                    friendItem.className = 'chat-list-item friend-item'; 
                    friendItem.dataset.chatID = friend.chatID; 
                    friendItem.dataset.otherUid = friendUid;
                    friendItem.dataset.otherName = friend.displayName;
                    friendItem.innerHTML = `
                        <h3>${friend.displayName}</h3>
                        <p>Friend since: ${new Date(friend.timestamp).toLocaleDateString()}</p>
                        <button class="square-btn type-b" style="width: auto; padding: 5px 10px;">âœ‰ï¸ Chat</button>
                    `;
                    // Click listener to open private chat directly
                    friendItem.addEventListener('click', () => {
                        handleNavigation('inbox-view');
                        openPrivateChat(friend.chatID, friendUid, friend.displayName);
                    });
                    friendsListContainer.appendChild(friendItem);
                });
            });
        };

        requestsContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('accept-request-btn')) {
                const senderUid = e.target.dataset.uid;
                const senderName = e.target.dataset.name;
                acceptFriendRequest(senderUid, senderName);
            } else if (e.target.classList.contains('reject-request-btn')) {
                const senderUid = e.target.dataset.uid;
                rejectFriendRequest(senderUid);
            }
        });


        // ***************************************************************
        // 10. MEDIA SHARING (UPLOAD/SEND) - REMOVED
        // ***************************************************************
        // All file upload/storage logic has been removed from this version of the code.

        
        // ***************************************************************
        // 9. ADMIN PANEL
        // ***************************************************************

        const loadAdminUsers = () => {
            const adminUsersList = document.getElementById('admin-users-list');
            onValue(usersRef, (snapshot) => {
                adminUsersList.innerHTML = '';
                snapshot.forEach(childSnapshot => {
                    const user = childSnapshot.val();
                    const uid = childSnapshot.key;
                    
                    const userItem = document.createElement('div');
                    userItem.className = 'chat-list-item'; 
                    userItem.innerHTML = `
                        <h3>${user.displayName || user.email} ${user.isAdmin ? '(ADMIN ğŸ‘‘)' : ''}</h3>
                        <p>UID: ${uid.substring(0, 8)}...</p>
                        <div style="display:flex; gap:5px;">
                            <button class="square-btn type-b" onclick="alert('Functionality to Block/Ban user: ${uid}')">ğŸš« Block</button>
                            <button class="square-btn type-b" style="background:#dc3545;" onclick="deleteUser('${uid}')">ğŸ—‘ï¸ Delete Data</button>
                        </div>
                    `;
                    adminUsersList.appendChild(userItem);
                });
            });
        };
        
        const loadAdminPublicMessages = () => {
            const adminPublicMessages = document.getElementById('admin-public-messages');
            const limitedMessagesQuery = query(messagesRef, limitToLast(50));
            
            onValue(limitedMessagesQuery, (snapshot) => {
                adminPublicMessages.innerHTML = '';
                snapshot.forEach(childSnapshot => {
                    const message = childSnapshot.val();
                    const messageKey = childSnapshot.key;
                    
                    const msgItem = document.createElement('div');
                    msgItem.className = 'message-card'; 
                    msgItem.innerHTML = `
                        <p><strong>${message.displayName} (${message.uid.substring(0, 4)}...)</strong>:</p>
                        <p>${message.text || '[Empty Message]'}</p>
                        <button class="square-btn type-b" style="background:#dc3545; padding: 5px 10px;" 
                                onclick="deletePublicMessage('${messageKey}')">âŒ Delete Message</button>
                    `;
                    adminPublicMessages.appendChild(msgItem);
                });
            });
        };

        // Exposed to global scope for onclick in HTML
        window.deletePublicMessage = (messageKey) => {
            if (!currentUserIsAdmin) {
                alert("ACCESS DENIED: You are not authorized to perform this action.");
                return;
            }
            if (confirm(`Are you sure you want to delete message ${messageKey}?`)) {
                remove(ref(db, `public_rooms/global/messages/${messageKey}`))
                    .then(() => alert("Message deleted successfully."))
                    .catch(e => alert("Error deleting message: " + e.message));
            }
        };

        // Exposed to global scope for onclick in HTML
        window.deleteUser = (uid) => {
             if (!currentUserIsAdmin) {
                alert("ACCESS DENIED: You are not authorized to perform this action.");
                return;
            }
            if (confirm(`Are you sure you want to delete all data for UID: ${uid}? (This only removes DB data, actual Auth user must be deleted manually)`)) {
                remove(ref(db, `users/${uid}`));
                remove(ref(db, `user_friends/${uid}`));
                alert("User data removed from Realtime DB/Friends List. (Manual deletion in Firebase Auth is required).");
            }
        }
        
        document.getElementById('admin-panel-btn').addEventListener('click', () => {
            if (currentUserIsAdmin) {
                handleNavigation('admin-view');
                loadAdminUsers();
                loadAdminPublicMessages(); 
            } else {
                alert("Access Denied.");
            }
        });
        
        document.querySelector('.admin-panel-tabs').addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON' && e.target.dataset.tab) {
                document.querySelectorAll('.admin-tab-content').forEach(tab => tab.style.display = 'none');
                document.querySelector('.admin-panel-tabs .active-tab')?.classList.remove('active-tab');
                
                document.getElementById(e.target.dataset.tab).style.display = 'block';
                e.target.classList.add('active-tab');
            }
        });


        // ***************************************************************
        // 1. UI AND NAVIGATION
        // ***************************************************************

        document.getElementById('bottom-nav').addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON' && e.target.dataset.view) {
                if (auth.currentUser || e.target.dataset.view === 'auth-view') {
                    handleNavigation(e.target.dataset.view);
                } else {
                    alert("Please sign in first!");
                    handleNavigation('auth-view');
                }
            }
        });
        
        document.getElementById('theme-toggle').addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
        });
        
    </script>
</body>
</html>
